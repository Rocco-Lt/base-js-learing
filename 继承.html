<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

<script>

    function Father(){
        this.name='lt'
        console.log(name);
    }
    function Son(){
        Father.call(this)
    }
 
 

    // 1.原型链继承(将父类的实例作为子类的实例)
    /*   function Father() {
          this.name = 'father';
          this.info = {
              age: 16,
              info: 'father'
          }
      }
      Father.prototype.getInfo = function () {
          console.log(this.name);
          console.log(this.info);
      }
      function Son() {ß
  
      }
      Son.prototype = new Father()
      let son1 = new Son();
      let son2 = new Son()
      son1.info.age = 19;
      console.log(son1);
      console.log(son2); */

    // 优点
    // 1.1父类方法可以复用
    // 缺点
    // 1.1父类的引用属性被子类共享。

    // 2/盗用构造函数继承
    //  call 
    /* function Parent(name) {
        this.info = { name: name };
    }
    Parent.prototype.getInfo = function () {
        console.log(3333);

    }
    function Child(name) {
        Parent.call(this, name);
        this.age = 18
    }

    let child1 = new Child("yhd");

    console.log(child1.info.name); // "yhd"
    console.log(child1.age); // 18

    let child2 = new Child("wxb");
    console.log(child2.info.name); // "wxb"
    console.log(child2.age); // 18 */
    // 优点：
    // 可以在子类构造函数中向父类传参数
    // 父类的引用属性不会被共享

    // 缺点：
    // 子类不能访问父类原型上定义的方法（即不能访问Parent.prototype上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化

    // 3.组合继承
    /*  function Parent(name) {
         this.name = name
         this.colors = ["red", "blue", "yellow"]
     }
     Parent.prototype.sayName = function () {
         console.log(this.name);
     }
 
     function Child(name, age) {
         // 继承父类属性
         Parent.call(this, name)
         this.age = age;
     }
     // 继承父类方法
     Child.prototype = new Parent();
 
     Child.prototype.sayAge = function () {
         console.log(this.age);
     }
 
     let child1 = new Child("yhd", 19);
     child1.colors.push("pink");
     console.log(child1.colors); // ["red", "blue", "yellow", "pink"]
     child1.sayAge(); // 19
     child1.sayName(); // "yhd"
 
     let child2 = new Child("wxb", 30);
     console.log(child2.colors);  // ["red", "blue", "yellow"]
     child2.sayAge(); // 30
     child2.sayName(); // "wxb" */

    // 4.原型式继承
   /*  function objectCopy(obj) {
        function Fun() { };
        Fun.prototype = obj;
        return new Fun()
    }

    let person = {
        name: "yhd",
        age: 18,
        friends: ["jack", "tom", "rose"],
        sayName: function () {
            console.log(this.name);
        }
    }

    let person1 = objectCopy(person);
    person1.name = "wxb";
    person1.friends.push("lily");
    person1.sayName(); // wxb

    let person2 = objectCopy(person);
    person2.name = "gsr";
    person2.friends.push("kobe");
    person2.sayName(); // "gsr"

    console.log(person.friends); // ["jack", "tom", "rose", "lily", "kobe"] */









</script>

</html>